%start lex_eoi
%start regex_eoi
%position<Int>
%derive<Show> Token
%derive<Show> ParseError

%token EOI
%token EOF          "eof"
%token PARSE_LBRACE "parse {"
%token REGEX        "regex"
%token AS           "as"
%token UNDERSCORE   "_"
%token RBRACE       "}"
%token LPAREN       "("
%token RPAREN       ")"
%token LBRACKET     "["
%token RBRACKET     "]"
%token EQ           "="
%token COLON        ":"
%token SEMICOLON    ";"
%token FAT_ARROW    "=>"
%token BAR          "|"
%token STAR         "*"
%token PLUS         "+"
%token QUESTION     "?"
%token MINUS        "-"
%token CARET        "^"
%token BACKSLASH // "\\"

%token<(String, String)> RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE
%token<String> LBRACE_CODE_RBRACE
%token<String> LC_IDENT
%token<Char> CHAR
%token<String> STRING

%{
let named_regexes: Map[String, @type.Regex] = {}

fn cleanup() -> Unit {
  named_regexes.clear()
}
%}

%%

lex_eoi -> @type.Lex
  : lex cleanup EOI                     { $1 }
  ;

cleanup -> Unit
  :                                     { cleanup() }
  ;

regex_eoi -> @type.Regex
  : regex EOI                           { $1 }
  ;

lex -> @type.Lex
  :                                     {
                                          { header: "", rules: [],  trailer: "" }
                                        }
  | header named_regex_list nonempty_rule_list trailer 
                                        {
                                          { header: $1, rules: $3.to_array(), trailer: $4 }
                                        }
  ;

header -> String
  : LBRACE_CODE_RBRACE                  { $1 }
  |                                     { "" }
  ;

trailer -> String 
  : LBRACE_CODE_RBRACE                  { $1 }
  |                                     { "" }
  ;

named_regex_list -> Unit
  : named_regex named_regex_list        {}
  |                                     {}
  ;

named_regex -> Unit
  : "regex" LC_IDENT "=" regex ";"        { named_regexes.set($2, $4) }
  ;

nonempty_rule_list -> @immut/list.T[@type.Rule]
  : rule                                { Cons($1, Nil) }
  | rule nonempty_rule_list             { Cons($1, $2) }
  ;

rule -> @type.Rule
  : RULE_LC_IDENT_LPAREN_CODE_RPAREN_ARROW_CODE_LBRACE "parse {" rule_item_list "}" "}" 
                                        {
                                          { name: $1.0, signature: $1.1, patterns: $3.to_array() }
                                        }
  ;

rule_item_list -> @immut/list.T[(@type.Regex, @type.CodeBlock)]
  : rule_item rule_item_list            { Cons($1, $2) }
  |                                     { Nil }
  ;

rule_item -> (@type.Regex, @type.CodeBlock)
  : regex "=>" LBRACE_CODE_RBRACE       { ($1, $3) }
  ;

regex -> @type.Regex
  : alias                               { $1 }
  ;

alias -> @type.Regex
  : alternation                         { $1 }
  | alternation "as" LC_IDENT           { @regex.bind($1, $3) }
  ;

alternation -> @type.Regex
  : concatenation                       { $1 }
  | concatenation "|" alternation       { @regex.alt($1, $3) }
  ;

concatenation -> @type.Regex
  : repetition                          { $1 }
  | repetition concatenation            { @regex.seq($1, $2) }
  | differentiation                     { $1 }
  ;

differentiation -> @type.Regex
  : atom BACKSLASH atom                 {
                                          guard $1 is Character(cset1) && $3 is Character(cset2)
                                          @regex.char_class(cset1.difference(cset2))
                                        }
  | differentiation BACKSLASH atom      { 
                                          guard $1 is Character(cset1) && $3 is Character(cset2)
                                          @regex.char_class(cset1.difference(cset2))
                                        }
  ;

repetition -> @type.Regex
  : atom                                { $1 }
  | atom "*"                            { @regex.star($1) }
  | atom "+"                            { @regex.plus($1) }
  | atom "?"                            { @regex.opt($1) }
  ;

atom -> @type.Regex
  : "(" alias ")"                       { $2 }
  | "(" LC_IDENT ":" alias ")"          { 
                                          match $2 {
                                            "ascii" => @regex.embed($4, encoding=Ascii)
                                            "latin1" => @regex.embed($4, encoding=Latin1)
                                            "utf8" => @regex.embed($4, encoding=Utf8)
                                            _ => panic()
                                          } 
                                        }
  | character_class                     { @regex.char_class($1) }
  | LC_IDENT                            { named_regexes.get($1).unwrap() }
  | CHAR                                { @regex.char_class(@char_set.singleton($1)) }
  | STRING                              { $1.iter().fold(init=@regex.epsilon, fn(acc, c) { @regex.seq(acc, @regex.char_class(@char_set.singleton(c))) }) }
  | UNDERSCORE                          { @regex.char_class(@char_set.any) }
  | EOF                                 { @regex.eof }
  ;

character_class -> @char_set.T
  : "[" character_class_inner "]"       { $2 }
  | "[" "^" character_class_inner "]"   { $3.negated() }
  ;

character_class_inner -> @char_set.T
  : character_class_item character_class_inner 
                                        { $1 + $2 }
  | character_class_item                { $1 }
  ;

character_class_item -> @char_set.T
  : CHAR                                { @char_set.singleton($1) }
  | CHAR "-" CHAR                       { @char_set.range($1, $3)}
  ;
